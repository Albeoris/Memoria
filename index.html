<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Memoria Catalog Editor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/css/select2.min.css" rel="stylesheet">
    <style>
        body.dark-theme { background-color: #121212; color: #e0e0e0; }
        .dark-theme input, .dark-theme select, .dark-theme textarea { background: #232323; color: #e0e0e0; border-color: #555; }
        .dark-theme .btn-primary { background-color: #0d6efd; border-color: #0d6efd; }
        .dark-theme .btn-secondary { background-color: #6c757d; border-color: #6c757d; }
        .dark-theme .btn-success { background-color: #198754; border-color: #198754; }
        .dark-theme .btn-info { background-color: #0dcaf0; border-color: #0dcaf0; color: #000; }
        .dark-theme .card { background-color: #1e1e1e !important; border-color: #555; }
        .dark-theme .card-body { background-color: #1e1e1e; }
        .dark-theme .bg-secondary { background-color: #2d2d2d !important; }
        textarea { resize: vertical; min-height: 60px; overflow-y: hidden; }
        .form-control:focus { box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25); }
        code { background-color: #2d2d2d; color: #f8f9fa; padding: 2px 4px; border-radius: 3px; }
        body.dark-theme .select2-container--default .select2-selection--single {
            background-color: #232323 !important;
            color: #e0e0e0 !important;
            border-color: #555 !important;
        }
        body.dark-theme .select2-container--default .select2-selection--single .select2-selection__rendered {
            color: #e0e0e0 !important;
        }
        body.dark-theme .select2-container--default .select2-dropdown {
            background-color: #232323 !important;
            color: #e0e0e0 !important;
            border-color: #555 !important;
        }
        body.dark-theme .select2-container--default .select2-results__option {
            background-color: #232323 !important;
            color: #e0e0e0 !important;
        }
        body.dark-theme .select2-container--default .select2-results__option--highlighted {
            background-color: #383838 !important;
            color: #fff !important;
        }
        body.dark-theme .select2-search--dropdown .select2-search__field {
            background: #232323 !important;
            color: #e0e0e0 !important;
            border-color: #555 !important;
        }
        body.dark-theme .bg-secondary,
        body.dark-theme .card.bg-secondary,
        body.dark-theme .card.bg-secondary .card-body {
            background-color: #232323 !important;
            color: #e0e0e0 !important;
        }
        body.dark-theme .bg-dark,
        body.dark-theme .card.bg-dark,
        body.dark-theme .card.bg-dark .card-body {
            background-color: #232323 !important;
            color: #e0e0e0 !important;
        }
        #changedModsSidebar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            background-color: #1e1e1e;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #changedModsSidebar h5 {
            margin-top: 0;
            color: #e0e0e0;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
        }
        .changed-mod-item {
            padding: 8px 12px;
            margin: 4px 0;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
            color: #e0e0e0;
            font-size: 0.9em;
        }
        .changed-mod-item:hover {
            background-color: #383838;
            border-color: #666;
        }
        .changed-mod-item.submod {
            margin-left: 16px;
            font-size: 0.85em;
            background-color: #252525;
        }
        .changed-mod-item.submod:before {
            content: "└ ";
            color: #888;
        }
        #changedModsSidebar.empty {
            display: none;
        }
    </style>
</head>
<body class="dark-theme">

<!-- Changed Mods Sidebar -->
<div id="changedModsSidebar" class="empty">
    <h5>Changed Mods</h5>
    <div id="changedModsList">
        <div class="text-muted small">No changes yet</div>
    </div>
</div>

<div class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>Memoria Mod Catalog Editor</h2>
        <div>
            <button id="testPreservationBtn" class="btn btn-outline-success btn-sm me-2" title="Test XML preservation system">
                Test Preservation
            </button>
            <a href="https://github.com/Albeoris/Memoria/edit/main/Memoria.Launcher/Catalogs/MemoriaCatalog.xml" 
               class="btn btn-outline-info btn-sm" target="_blank" rel="noopener noreferrer">
                Raw Edit
            </a>
        </div>
    </div>

    <!-- Help Section -->
    <div class="mb-4">
        <button class="btn btn-info btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#helpSection" aria-expanded="false">
            Show Instructions
        </button>
        <div class="collapse mt-2" id="helpSection">
            <div class="card bg-secondary">
                <div class="card-body">
                    <h5>How to use this editor:</h5>
                    <ol>
                        <li><strong>Authentication:</strong> Click "Login with GitHub" and enter your Personal Access Token.
                            <br><small>Create one at: GitHub Settings > Developer settings > Personal access tokens > Tokens (classic)<br>
                                Required scopes: <code>repo</code>, <code>workflow</code></small></li>
                        <li><strong>Select Mod:</strong> Choose an existing mod from the dropdown to edit it.</li>
                        <li><strong>Select Sub-mod:</strong> Choose "Main" to edit the main mod, or select a sub-mod to edit it specifically.</li>
                        <li><strong>Edit Fields:</strong> Fill in the form with your changes. Required fields are marked with *.</li>
                        <li><strong>Create New:</strong> Use "Create New Mod" or "Create New SubMod" buttons to add new content.</li>
                        <li><strong>Save:</strong> Click "Save Changes" to create a Pull Request with your modifications.</li>
                    </ol>
                    <p><strong>Note:</strong> All changes create Pull Requests that need to be reviewed and merged by repository maintainers.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Authentication Section -->
    <div id="authSection" class="mb-4">
        <div class="card bg-dark">
            <div class="card-body">
                <h5 class="card-title">GitHub Authentication</h5>
                <p class="card-text">You need to authenticate with GitHub to save changes.</p>
                <button id="authBtn" class="btn btn-primary">Login with GitHub</button>
                <div id="authStatus" class="mt-2" style="display:none;">
                    <span class="text-success">✓ Authenticated as <span id="username"></span></span>
                    <button id="logoutBtn" class="btn btn-sm btn-outline-secondary ms-2">Logout</button>
                </div>
            </div>
        </div>
    </div>

    <!-- GitHub Device Flow Modal -->
    <div class="modal fade" id="deviceFlowModal" tabindex="-1" aria-labelledby="deviceFlowModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header border-0">
                    <h5 class="modal-title" id="deviceFlowModalLabel">GitHub Login</h5>
                </div>
                <div class="modal-body">
                    <div id="deviceFlowStep1">
                        <p>1. Click the button below to open the GitHub authentication page.<br>
                            2. Enter this code:</p>
                        <div class="mb-3">
                            <input id="deviceUserCode" class="form-control fw-bold text-center" readonly style="font-size:1.4em;">
                        </div>
                        <button class="btn btn-info w-100" id="deviceFlowOpenBtn" target="_blank">Open GitHub & Authorize</button>
                    </div>
                    <div id="deviceFlowStep2" style="display:none;">
                        <div class="d-flex align-items-center mb-2">
                            <div class="spinner-border spinner-border-sm me-2"></div>
                            <div>Waiting for authorization...</div>
                        </div>
                        <div class="text-muted">After approving in GitHub, this window will close automatically.</div>
                    </div>
                    <div id="deviceFlowError" class="alert alert-danger mt-2 d-none"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="mb-3">
        <label>Select Mod:</label>
        <select id="modSelect" class="form-select"></select>
    </div>
    <div class="mb-3">
        <label>Select Sub-mod:</label>
        <select id="submodSelect" class="form-select"></select>
    </div>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" class="alert alert-info" style="display:none;">
        <div class="d-flex align-items-center">
            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
            <span>Loading...</span>
        </div>
    </div>

    <form id="modForm">
        <div class="mb-3">
            <label>Name *</label>
            <input id="name" class="form-control" required>
        </div>
        <div id="mainModFields" class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Installation Path *</label>
                    <input id="path" class="form-control" required>
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Version *</label>
                    <input id="version" class="form-control" required>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Author *</label>
                    <input id="author" class="form-control" required>
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Priority</label>
                    <input id="priority" type="number" class="form-control">
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Category</label>
                    <input id="category" class="form-control">
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Release Date</label>
                    <input id="releaseDate" type="date" class="form-control">
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Website</label>
                    <input id="website" type="url" class="form-control">
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Download URL</label>
                    <input id="downloadUrl" type="url" class="form-control">
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Preview File URL</label>
                    <input id="previewFileUrl" type="url" class="form-control">
                </div>
            </div>
            <div class="col-md-6">
                <div class="mb-3">
                    <label>Patch Notes</label>
                    <textarea id="patchNotes" class="form-control" rows="3"></textarea>
                </div>
            </div>
        </div>
        <div class="mb-3"><label>Description *</label><textarea id="description" class="form-control" required rows="4"></textarea></div>
        <div class="mb-3"><label>Incompatible With</label><input id="incompatibleWith" class="form-control" placeholder="Comma-separated list of mod names"></div>
        <div class="mb-3"><label>Minimum Memoria Version</label><input id="minimumMemoriaVersion" class="form-control" placeholder="YYYY-MM-DD"></div>

        <div class="mb-3">
            <button type="button" id="newModBtn" class="btn btn-primary me-2">Create New Mod</button>
            <button type="button" id="newSubmodBtn" class="btn btn-secondary me-2">Create New SubMod</button>
            <button type="submit" id="saveBtn" class="btn btn-success">Save Changes</button>
            <div id="prLinkContainer" class="d-inline-block ms-3" style="display:none;">
                <a id="prLink" href="#" target="_blank" class="btn btn-outline-info btn-sm">View Pull Request</a>
            </div>
            <div id="createPrContainer" class="d-inline-block ms-3" style="display:none;">
                <span class="text-info small">Create Pull Request button will appear after first successful save</span>
            </div>
        </div>
    </form>
</div>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/js/select2.min.js"></script>

<script>
    (async function () {
        // GitHub API configuration
        const REPO_OWNER = 'Albeoris';
        const REPO_NAME = 'Memoria';
        const CATALOG_PATH = 'Memoria.Launcher/Catalogs/MemoriaCatalog.xml';

        let accessToken = localStorage.getItem('github_token');
        let currentUser = null;
        let modSelect = null;
        let submodSelect = null;
        let mods = [];
        
        // Enhanced XML preservation system
        let originalXmlText = ''; // Store the complete original XML text
        let originalModsOrder = []; // Store original order of mods
        let originalModXml = new Map(); // mod DOM element -> original XML text
        let originalSubmodXml = new Map(); // submod DOM element -> original XML text  
        let modifiedMods = new Set(); // Track which mods have been modified
        let modifiedSubmods = new Set(); // Track which submods have been modified
        let xmlChunks = []; // Store XML as chunks (text, mod elements, etc.)
        let modToChunkIndex = new Map(); // Map mod element to its chunk index
        let hasSuccessfulSave = localStorage.getItem('memoria_has_successful_save') === 'true'; // Track first successful save
        
        // Track original form values to detect actual changes
        let originalFormValues = {};
        let isLoadingFormData = false; // Flag to prevent modification tracking during form loading

        // Function to update the changed mods sidebar
        function updateChangedModsSidebar() {
            const changedModsList = $('#changedModsList');
            const sidebar = $('#changedModsSidebar');
            
            // Clear existing content
            changedModsList.empty();
            
            const changedItems = [];
            
            // Add changed main mods
            modifiedMods.forEach(mod => {
                const modName = mod.querySelector('Name')?.textContent || 'Unknown Mod';
                changedItems.push({
                    name: modName,
                    type: 'mod',
                    element: mod,
                    isSubmod: false
                });
            });
            
            // Add changed submods
            modifiedSubmods.forEach(submod => {
                const submodName = submod.querySelector('Name')?.textContent || 'Unknown SubMod';
                const parentMod = submod.closest('Mod');
                const parentName = parentMod?.querySelector('Name')?.textContent || 'Unknown Mod';
                changedItems.push({
                    name: `${parentName} → ${submodName}`,
                    type: 'submod',
                    element: submod,
                    parentElement: parentMod,
                    isSubmod: true
                });
            });
            
            if (changedItems.length === 0) {
                changedModsList.append('<div class="text-muted small">No changes yet</div>');
                sidebar.addClass('empty');
            } else {
                sidebar.removeClass('empty');
                
                // Sort items alphabetically
                changedItems.sort((a, b) => a.name.localeCompare(b.name));
                
                changedItems.forEach(item => {
                    const itemDiv = $(`<div class="changed-mod-item ${item.type}" data-mod-name="${item.element.querySelector('Name')?.textContent || ''}" data-is-submod="${item.isSubmod}">${item.name}</div>`);
                    
                    // Add click handler
                    itemDiv.click(() => {
                        selectModInUI(item.element, item.parentElement, item.isSubmod);
                    });
                    
                    changedModsList.append(itemDiv);
                });
            }
        }
        
        // Function to select a mod/submod in the UI
        function selectModInUI(element, parentElement, isSubmod) {
            if (isSubmod && parentElement) {
                // Find parent mod in the sorted mods array
                const parentName = parentElement.querySelector('Name')?.textContent;
                const modIndex = mods.findIndex(mod => mod.querySelector('Name')?.textContent === parentName);
                
                if (modIndex !== -1) {
                    // Select the parent mod first
                    modSelect.val(modSelect.find('option').eq(modIndex).val()).trigger('change');
                    
                    // Then select the submod
                    setTimeout(() => {
                        const submodName = element.querySelector('Name')?.textContent;
                        const submodOption = submodSelect.find('option').filter(function() {
                            return $(this).text() === submodName;
                        });
                        if (submodOption.length > 0) {
                            submodSelect.val(submodOption.val()).trigger('change');
                        }
                    }, 100);
                }
            } else {
                // Select main mod
                const modName = element.querySelector('Name')?.textContent;
                const modIndex = mods.findIndex(mod => mod.querySelector('Name')?.textContent === modName);
                
                if (modIndex !== -1) {
                    modSelect.val(modSelect.find('option').eq(modIndex).val()).trigger('change');
                    // Select 'Main' for the submod
                    setTimeout(() => {
                        submodSelect.val(submodSelect.find('option').first().val()).trigger('change');
                    }, 100);
                }
            }
        }
        
        // Function to reset changed mods tracking
        function resetChangedMods() {
            modifiedMods.clear();
            modifiedSubmods.clear();
            updateChangedModsSidebar();
        }

        // Check if access_token present in URL
        function extractTokenFromUrl() {
            const url = new URL(window.location.href);
            const token = url.searchParams.get('token');
            if (token) {
                localStorage.setItem('github_token', token);
                // Remove ?token=... from history without reloading
                url.searchParams.delete('token');
                window.history.replaceState({}, document.title, url.pathname + url.search);
                return token;
            }
            return null;
        }

        // Try to extract token at page load
        const justReceivedToken = extractTokenFromUrl();
        if (justReceivedToken) {
            accessToken = justReceivedToken;
        }

        function updateAuthUI() {
            if (accessToken && currentUser) {
                $('#authSection .card-text').text(`Authenticated as ${currentUser.login}`);
                $('#authBtn').hide();
                $('#authStatus').show();
                $('#username').text(currentUser.login);
            } else {
                $('#authBtn').show();
                $('#authStatus').hide();
            }
        }

        async function validateToken() {
            if (!accessToken) return false;
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                if (response.ok) {
                    currentUser = await response.json();
                    updateAuthUI();
                    return true;
                } else {
                    localStorage.removeItem('github_token');
                    accessToken = null;
                    updateAuthUI();
                    return false;
                }
            } catch (error) {
                console.error('Token validation error:', error);
                return false;
            }
        }

        $('#authBtn').click(() => {
            const OAUTH_ENDPOINT = "https://memoria-oauth.netlify.app/.netlify/functions/auth";
            window.location.href = OAUTH_ENDPOINT;
        });

        $('#logoutBtn').click(() => {
            localStorage.removeItem('github_token');
            accessToken = null;
            currentUser = null;
            updateAuthUI();
        });

        function reconstructModWithSubmodPreservation(mod) {
            // Get the original mod XML
            let modXml = originalModXml.get(mod);
            if (!modXml) {
                // Fallback: find original XML by mod name
                const modName = mod.querySelector('Name')?.textContent;
                for (const [originalMod, xml] of originalModXml.entries()) {
                    if (originalMod.querySelector('Name')?.textContent === modName) {
                        modXml = xml;
                        break;
                    }
                }
                
                if (!modXml) {
                    // Final fallback to serialization if no original XML found
                    const serializer = new XMLSerializer();
                    return serializer.serializeToString(mod);
                }
            }
            
            // Check if any submods were modified by comparing names instead of object references
            const submods = mod.querySelectorAll('SubMod');
            let hasModifiedSubmods = false;
            
            submods.forEach(submod => {
                const submodName = submod.querySelector('Name')?.textContent;
                const isSubmodModified = Array.from(modifiedSubmods).some(modifiedSubmod => 
                    modifiedSubmod.querySelector('Name')?.textContent === submodName &&
                    modifiedSubmod.closest('Mod').querySelector('Name')?.textContent === mod.querySelector('Name')?.textContent);
                
                if (isSubmodModified) {
                    hasModifiedSubmods = true;
                }
            });
            
            if (!hasModifiedSubmods) {
                // No submods modified, but main mod fields might be modified
                // We need to update the mod fields while preserving submod structure
                return updateModFieldsInXmlText(modXml, mod);
            } else {
                // Some submods modified - need to replace individual submods
                let reconstructedModXml = modXml;
                
                submods.forEach(submod => {
                    const submodName = submod.querySelector('Name')?.textContent;
                    const isSubmodModified = Array.from(modifiedSubmods).some(modifiedSubmod => 
                        modifiedSubmod.querySelector('Name')?.textContent === submodName &&
                        modifiedSubmod.closest('Mod').querySelector('Name')?.textContent === mod.querySelector('Name')?.textContent);
                    
                    if (isSubmodModified) {
                        // Find the actual modified submod element
                        const actualModifiedSubmod = Array.from(modifiedSubmods).find(modifiedSubmod => 
                            modifiedSubmod.querySelector('Name')?.textContent === submodName &&
                            modifiedSubmod.closest('Mod').querySelector('Name')?.textContent === mod.querySelector('Name')?.textContent);
                        
                        if (actualModifiedSubmod) {
                            // Find original submod XML by name within this mod's XML
                            const originalSubmodXml = findSubmodXmlInModXml(modXml, submodName);
                            if (originalSubmodXml) {
                                // Create updated submod XML
                                const updatedSubmodXml = updateSubmodFieldsInXmlText(originalSubmodXml, actualModifiedSubmod);
                                
                                // Replace in the mod XML
                                reconstructedModXml = reconstructedModXml.replace(originalSubmodXml, updatedSubmodXml);
                            }
                        }
                    }
                });
                
                // Also update main mod fields
                return updateModFieldsInXmlText(reconstructedModXml, mod);
            }
        }
        
        // Helper function to find submod XML text within mod XML by submod name
        function findSubmodXmlInModXml(modXmlText, submodName) {
            const submodStart = modXmlText.indexOf(`<Name>${submodName}</Name>`);
            if (submodStart > -1) {
                // Find the enclosing SubMod tags
                const beforeName = modXmlText.lastIndexOf('<SubMod>', submodStart);
                const afterName = modXmlText.indexOf('</SubMod>', submodStart) + 9;
                if (beforeName > -1 && afterName > -1) {
                    return modXmlText.substring(beforeName, afterName);
                }
            }
            return null;
        }
        
        // Helper function to extract original value from XML text using regex
        function getValueFromXmlText(xmlText, fieldName) {
            const fieldRegex = new RegExp(`<${fieldName}>([^<]*)</${fieldName}>`, 'i');
            const match = xmlText.match(fieldRegex);
            return match ? match[1] : '';
        }
        
        function updateModFieldsInXmlText(xmlText, modElement) {
            // Update mod fields in the XML text while preserving formatting
            let updatedXml = xmlText;
            
            // Helper function to update a specific field
            function updateField(fieldName, newValue) {
                // Compare new value with ORIGINAL value from xmlText, not DOM element
                const valueFromXmlText = getValueFromXmlText(xmlText, fieldName);
                
                if (newValue !== valueFromXmlText) {
                    const fieldRegex = new RegExp(`(<${fieldName}>)[^<]*(</\s*${fieldName}>)`, 'g');
                    if (newValue) {
                        if (xmlText.includes(`<${fieldName}>`)) {
                            updatedXml = updatedXml.replace(fieldRegex, `$1${newValue}$2`);
                        } else {
                            // Field doesn't exist in original XML, need to add it
                            // Add after the Name field
                            const nameEndPos = updatedXml.indexOf('</Name>') + 7;
                            if (nameEndPos > 6) {
                                updatedXml = updatedXml.substring(0, nameEndPos) + 
                                    `\n\t<${fieldName}>${newValue}</${fieldName}>` +
                                    updatedXml.substring(nameEndPos);
                            }
                        }
                    } else {
                        // Remove field if empty
                        updatedXml = updatedXml.replace(fieldRegex, '');
                    }
                }
            }
            
            // Update all possible mod fields
            updateField('Name', modElement.querySelector('Name')?.textContent || '');
            updateField('Version', modElement.querySelector('Version')?.textContent || '');
            updateField('InstallationPath', modElement.querySelector('InstallationPath')?.textContent || '');
            updateField('Author', modElement.querySelector('Author')?.textContent || '');
            updateField('Description', modElement.querySelector('Description')?.textContent || '');
            updateField('Priority', modElement.querySelector('Priority')?.textContent || '');
            updateField('Category', modElement.querySelector('Category')?.textContent || '');
            updateField('ReleaseDate', modElement.querySelector('ReleaseDate')?.textContent || '');
            updateField('Website', modElement.querySelector('Website')?.textContent || '');
            updateField('DownloadUrl', modElement.querySelector('DownloadUrl')?.textContent || '');
            updateField('PreviewFileUrl', modElement.querySelector('PreviewFileUrl')?.textContent || '');
            updateField('PatchNotes', modElement.querySelector('PatchNotes')?.textContent || '');
            updateField('IncompatibleWith', modElement.querySelector('IncompatibleWith')?.textContent || '');
            updateField('MinimumMemoriaVersion', modElement.querySelector('MinimumMemoriaVersion')?.textContent || '');
            
            return updatedXml;
        }
        
        function updateSubmodFieldsInXmlText(xmlText, submodElement) {
            // Similar to updateModFieldsInXmlText but for submods
            let updatedXml = xmlText;
            
            function updateField(fieldName, newValue) {
                // Compare new value with ORIGINAL value from xmlText, not DOM element
                const valueFromXmlText = getValueFromXmlText(xmlText, fieldName);
                
                if (newValue !== valueFromXmlText) {
                    const fieldRegex = new RegExp(`(<${fieldName}>)[^<]*(</\s*${fieldName}>)`, 'g');
                    if (newValue) {
                        if (xmlText.includes(`<${fieldName}>`)) {
                            updatedXml = updatedXml.replace(fieldRegex, `$1${newValue}$2`);
                        } else {
                            // Field doesn't exist in original XML, need to add it
                            const nameEndPos = updatedXml.indexOf('</Name>') + 7;
                            if (nameEndPos > 6) {
                                updatedXml = updatedXml.substring(0, nameEndPos) + 
                                    `\n\t\t<${fieldName}>${newValue}</${fieldName}>` +
                                    updatedXml.substring(nameEndPos);
                            }
                        }
                    } else {
                        // Remove field if empty
                        updatedXml = updatedXml.replace(fieldRegex, '');
                    }
                }
            }
            
            // Update submod fields
            updateField('Name', submodElement.querySelector('Name')?.textContent || '');
            updateField('Version', submodElement.querySelector('Version')?.textContent || '');
            updateField('InstallationPath', submodElement.querySelector('InstallationPath')?.textContent || '');
            updateField('Description', submodElement.querySelector('Description')?.textContent || '');
            updateField('Priority', submodElement.querySelector('Priority')?.textContent || '');
            updateField('Category', submodElement.querySelector('Category')?.textContent || '');
            updateField('ReleaseDate', submodElement.querySelector('ReleaseDate')?.textContent || '');
            updateField('Website', submodElement.querySelector('Website')?.textContent || '');
            updateField('DownloadUrl', submodElement.querySelector('DownloadUrl')?.textContent || '');
            updateField('PreviewFileUrl', submodElement.querySelector('PreviewFileUrl')?.textContent || '');
            updateField('PatchNotes', submodElement.querySelector('PatchNotes')?.textContent || '');
            updateField('IncompatibleWith', submodElement.querySelector('IncompatibleWith')?.textContent || '');
            updateField('MinimumMemoriaVersion', submodElement.querySelector('MinimumMemoriaVersion')?.textContent || '');
            
            return updatedXml;
        }
        
        function createModElementAsXmlString(isSubmod) {
            const tagName = isSubmod ? 'SubMod' : 'Mod';
            const indent = isSubmod ? '\t\t' : '\t';
            
            let xml = `<${tagName}>`;
            
            function addField(fieldName, value) {
                if (value) {
                    xml += `\n${indent}<${fieldName}>${value}</${fieldName}>`;
                }
            }
            
            addField('Name', $('#name').val());
            if (!isSubmod || $('#version').val()) {
                addField('Version', $('#version').val());
            }
            if (!isSubmod) {
                addField('Priority', $('#priority').val());
                addField('InstallationPath', $('#path').val());
                addField('ReleaseDate', $('#releaseDate').val());
                addField('Author', $('#author').val());
            } else {
                addField('InstallationPath', $('#path').val());
            }
            addField('Description', $('#description').val());
            addField('PatchNotes', $('#patchNotes').val());
            addField('Category', $('#category').val());
            addField('Website', $('#website').val());
            addField('DownloadUrl', $('#downloadUrl').val());
            addField('PreviewFileUrl', $('#previewFileUrl').val());
            addField('IncompatibleWith', $('#incompatibleWith').val());
            addField('MinimumMemoriaVersion', $('#minimumMemoriaVersion').val());
            
            xml += `\n${isSubmod ? '\t' : ''}</${tagName}>`;
            return xml;
        }

        function parseXmlIntoChunks(xmlText) {
            xmlChunks = [];
            modToChunkIndex.clear();
            
            const xmlDoc = new DOMParser().parseFromString(xmlText, 'application/xml');
            const catalogElement = xmlDoc.querySelector('ModCatalog');
            
            if (!catalogElement) {
                throw new Error('Invalid catalog XML - no ModCatalog element found');
            }
            
            // Track position in original text
            let currentPos = 0;
            
            // Add opening tag and any content before first mod
            const firstModStart = xmlText.indexOf('<Mod>');
            if (firstModStart > 0) {
                xmlChunks.push({
                    type: 'text',
                    content: xmlText.substring(0, firstModStart)
                });
                currentPos = firstModStart;
            }
            
            // Process each mod element
            const mods = Array.from(catalogElement.querySelectorAll('Mod'));
            originalModsOrder = [...mods];
            
            for (let i = 0; i < mods.length; i++) {
                const mod = mods[i];
                
                // Find the complete mod text in original XML
                const modStartPos = xmlText.indexOf('<Mod>', currentPos);
                const modEndPos = xmlText.indexOf('</Mod>', modStartPos) + 6; // +6 for '</Mod>'
                
                if (modStartPos === -1 || modEndPos === -1) {
                    throw new Error(`Could not find mod boundaries for mod ${i}`);
                }
                
                const modXmlText = xmlText.substring(modStartPos, modEndPos);
                
                // Store original XML for this mod
                originalModXml.set(mod, modXmlText);
                
                // Store submods original XML
                const submods = mod.querySelectorAll('SubMod');
                submods.forEach(submod => {
                    // Find submod text within the mod text
                    const submodName = submod.querySelector('Name')?.textContent || '';
                    if (submodName) {
                        // Look for this submod in the mod XML text
                        const submodStart = modXmlText.indexOf(`<Name>${submodName}</Name>`);
                        if (submodStart > -1) {
                            // Find the enclosing SubMod tags
                            const beforeName = modXmlText.lastIndexOf('<SubMod>', submodStart);
                            const afterName = modXmlText.indexOf('</SubMod>', submodStart) + 9;
                            if (beforeName > -1 && afterName > -1) {
                                const submodXmlText = modXmlText.substring(beforeName, afterName);
                                originalSubmodXml.set(submod, submodXmlText);
                            }
                        }
                    }
                });
                
                // Add mod chunk
                const chunkIndex = xmlChunks.length;
                xmlChunks.push({
                    type: 'mod',
                    element: mod,
                    originalContent: modXmlText
                });
                modToChunkIndex.set(mod, chunkIndex);
                
                currentPos = modEndPos;
                
                // Add any text between this mod and the next one
                const nextModStart = i < mods.length - 1 ? 
                    xmlText.indexOf('<Mod>', currentPos) : 
                    xmlText.indexOf('</ModCatalog>', currentPos);
                    
                if (nextModStart > currentPos) {
                    xmlChunks.push({
                        type: 'text',
                        content: xmlText.substring(currentPos, nextModStart)
                    });
                    currentPos = nextModStart;
                }
            }
            
            // Add closing tag and any remaining content
            const closingPos = xmlText.indexOf('</ModCatalog>', currentPos);
            if (closingPos > -1) {
                xmlChunks.push({
                    type: 'text',
                    content: xmlText.substring(currentPos)  // Include everything from current position to end
                });
            }
        }
        
        // Testing and validation functions for XML preservation
        function testXmlPreservation() {
            console.log('Testing XML preservation system...');
            
            // Test 1: Verify chunk reconstruction produces identical XML when no changes made
            let reconstructedXml = '';
            for (let i = 0; i < xmlChunks.length; i++) {
                const chunk = xmlChunks[i];
                if (chunk.type === 'text') {
                    reconstructedXml += chunk.content;
                } else if (chunk.type === 'mod') {
                    reconstructedXml += chunk.originalContent;
                }
            }
            
            const isIdentical = reconstructedXml === originalXmlText;
            console.log('Test 1 - Perfect reconstruction without changes:', isIdentical);
            
            if (!isIdentical) {
                console.log('Original length:', originalXmlText.length);
                console.log('Reconstructed length:', reconstructedXml.length);
                // Find first difference
                for (let i = 0; i < Math.min(originalXmlText.length, reconstructedXml.length); i++) {
                    if (originalXmlText[i] !== reconstructedXml[i]) {
                        console.log('First difference at position', i);
                        console.log('Original:', originalXmlText.substring(i-10, i+10));
                        console.log('Reconstructed:', reconstructedXml.substring(i-10, i+10));
                        break;
                    }
                }
            }
            
            // Test 2: Verify original order is preserved in chunks
            const originalModOrder = originalModsOrder.map(mod => mod.querySelector('Name')?.textContent);
            const chunkModOrder = xmlChunks
                .filter(chunk => chunk.type === 'mod')
                .map(chunk => chunk.element.querySelector('Name')?.textContent);
            
            const orderPreserved = JSON.stringify(originalModOrder) === JSON.stringify(chunkModOrder);
            console.log('Test 2 - Original mod order preserved:', orderPreserved);
            
            // Test 3: Verify UI displays alphabetically
            const uiModOrder = Array.from(mods).map(mod => mod.querySelector('Name')?.textContent);
            const sortedOrder = [...originalModOrder].sort((a, b) => a.localeCompare(b));
            const uiAlphabetical = JSON.stringify(uiModOrder) === JSON.stringify(sortedOrder);
            console.log('Test 3 - UI displays alphabetically:', uiAlphabetical);
            
            // Test 4: Test mod name-based matching (new test)
            console.log('Test 4 - Testing mod name-based matching...');
            const testModName = mods[0]?.querySelector('Name')?.textContent;
            if (testModName) {
                // Find chunk with this mod name
                const foundChunk = xmlChunks.find(chunk => 
                    chunk.type === 'mod' && 
                    chunk.element.querySelector('Name')?.textContent === testModName);
                console.log('Found chunk for mod:', testModName, ':', !!foundChunk);
                
                // Test finding mod in sorted array
                const foundInSorted = mods.find(mod => 
                    mod.querySelector('Name')?.textContent === testModName);
                console.log('Found in sorted array:', !!foundInSorted);
            }
            
            return {
                perfectReconstruction: isIdentical,
                orderPreserved: orderPreserved,
                uiAlphabetical: uiAlphabetical
            };
        }

        await validateToken();
        
        // Update PR button visibility based on save history
        function updatePrButtonVisibility() {
            if (hasSuccessfulSave) {
                $('#createPrContainer').hide();
                // Don't show PR link container here, only after successful save
            } else {
                $('#createPrContainer').show();
                $('#prLinkContainer').hide(); // Ensure PR link is hidden initially
            }
        }
        
        // Initialize PR button visibility
        updatePrButtonVisibility();

        function showLoading(message = 'Loading...') {
            $('#loadingIndicator').text(message).show();
        }

        function hideLoading() {
            $('#loadingIndicator').hide();
        }

        try {
            showLoading('Loading mod catalog...');
            const isLocalhost = location.hostname === "localhost" || location.hostname === "127.0.0.1";
            const xmlUrl = isLocalhost
                ? "MemoriaCatalog.xml"
                : "https://raw.githubusercontent.com/Albeoris/Memoria/main/Memoria.Launcher/Catalogs/MemoriaCatalog.xml";
            const xmlText = await fetch(xmlUrl).then(r => r.text());
            
            // Store original XML text
            originalXmlText = xmlText;
            
            const xmlDoc = new DOMParser().parseFromString(xmlText, 'application/xml');
            mods = Array.from(xmlDoc.querySelectorAll('ModCatalog > Mod'));
            
            // Parse XML into chunks for preservation
            parseXmlIntoChunks(xmlText);
            
            // Test the preservation system
            const testResults = testXmlPreservation();
            console.log('XML Preservation Test Results:', testResults);
            
            // Sort mods alphabetically for UI display (originalModsOrder preserves original order)
            mods.sort((a, b) => a.querySelector('Name').textContent.localeCompare(b.querySelector('Name').textContent));

            modSelect = $('#modSelect');
            submodSelect = $('#submodSelect');

            mods.forEach(mod => modSelect.append(new Option(mod.querySelector('Name').textContent)));

            modSelect.select2();
            submodSelect.select2();
            
            // Initialize the sidebar
            updateChangedModsSidebar();

            hideLoading();
        } catch (error) {
            hideLoading();
            alert('Error loading mod catalog: ' + error.message);
            console.error('Loading error:', error);
        }

        function autosizeTextarea(el) {
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        function saveToXmlElement() {
            // Skip if currently loading form data
            if (isLoadingFormData) return;
            
            const modIndex = modSelect.prop('selectedIndex');
            const submodDisplayIndex = submodSelect.prop('selectedIndex') - 1; // -1 because 'Main' is at index 0
            const isSubmod = submodDisplayIndex >= 0;
            
            if (modIndex < 0 || !mods[modIndex]) return; // No mod selected
            
            let targetElement;
            if (isSubmod) {
                // Get submods in alphabetical order to match the UI display
                const submods = Array.from(mods[modIndex].querySelectorAll('SubMod'));
                submods.sort((a, b) => a.querySelector('Name').textContent.localeCompare(b.querySelector('Name').textContent));
                targetElement = submods[submodDisplayIndex];
            } else {
                targetElement = mods[modIndex];
            }
            
            if (!targetElement) return;
            
            // Check if any values actually changed
            let hasChanges = false;
            $('#modForm input, #modForm textarea').each(function() {
                const currentValue = $(this).val();
                const originalValue = originalFormValues[this.id] || '';
                if (currentValue !== originalValue) {
                    hasChanges = true;
                    return false; // Break out of each loop
                }
            });
            
            if (!hasChanges) return; // No actual changes, don't mark as modified
            
            // Update XML element with current form values
            updateElementText(targetElement, 'Name', $('#name').val());
            updateElementText(targetElement, 'Version', $('#version').val());
            updateElementText(targetElement, 'Description', $('#description').val());
            updateElementText(targetElement, 'PatchNotes', $('#patchNotes').val());
            updateElementText(targetElement, 'Priority', $('#priority').val());
            updateElementText(targetElement, 'Category', $('#category').val());
            updateElementText(targetElement, 'Website', $('#website').val());
            updateElementText(targetElement, 'DownloadUrl', $('#downloadUrl').val());
            updateElementText(targetElement, 'PreviewFileUrl', $('#previewFileUrl').val());
            updateElementText(targetElement, 'IncompatibleWith', $('#incompatibleWith').val());
            updateElementText(targetElement, 'MinimumMemoriaVersion', $('#minimumMemoriaVersion').val());
            updateElementText(targetElement, 'ReleaseDate', $('#releaseDate').val());
            if (!isSubmod) {
                updateElementText(targetElement, 'InstallationPath', $('#path').val());
                updateElementText(targetElement, 'Author', $('#author').val());
            }
            
            // Mark as modified for preservation system only when there are actual changes
            if (isSubmod) {
                modifiedSubmods.add(targetElement);
            } else {
                modifiedMods.add(targetElement);
            }
            
            // Update the sidebar to reflect changes
            updateChangedModsSidebar();
        }

        function fillForm(modElement, isSubmod) {
            // Set loading flag to prevent modification tracking
            isLoadingFormData = true;
            
            // Always load from XML element
            $('#modForm input, #modForm textarea').val('');
            $('#name').val(modElement.querySelector('Name')?.textContent || '');
            $('#version').val(modElement.querySelector('Version')?.textContent || '');
            $('#description').val(modElement.querySelector('Description')?.textContent || '');
            $('#patchNotes').val(modElement.querySelector('PatchNotes')?.textContent || '');
            $('#priority').val(modElement.querySelector('Priority')?.textContent || '');
            $('#category').val(modElement.querySelector('Category')?.textContent || '');
            $('#website').val(modElement.querySelector('Website')?.textContent || '');
            $('#downloadUrl').val(modElement.querySelector('DownloadUrl')?.textContent || '');
            $('#previewFileUrl').val(modElement.querySelector('PreviewFileUrl')?.textContent || '');
            $('#incompatibleWith').val(modElement.querySelector('IncompatibleWith')?.textContent || '');
            $('#minimumMemoriaVersion').val(modElement.querySelector('MinimumMemoriaVersion')?.textContent || '');
            const releaseDate = modElement.querySelector('ReleaseDate')?.textContent;
            if (releaseDate) {
                try {
                    const date = new Date(releaseDate);
                    if (!isNaN(date.getTime())) {
                        $('#releaseDate').val(date.toISOString().split('T')[0]);
                    }
                } catch (e) {
                    $('#releaseDate').val('');
                }
            }
            if (!isSubmod) {
                $('#path').val(modElement.querySelector('InstallationPath')?.textContent || '');
                $('#author').val(modElement.querySelector('Author')?.textContent || '');
            }
            
            // Capture original form values for change detection
            originalFormValues = {};
            $('#modForm input, #modForm textarea').each(function() {
                originalFormValues[this.id] = $(this).val();
            });
            
            $('#mainModFields').toggle(!isSubmod);
            $('#version').prop('required', !isSubmod);
            autosizeTextarea(document.getElementById('description'));
            autosizeTextarea(document.getElementById('patchNotes'));
            
            // Clear loading flag
            isLoadingFormData = false;
        }

        function updateSubmods() {
            submodSelect.empty().append(new Option('Main'));
            const mod = mods[modSelect.prop('selectedIndex')];
            const submods = Array.from(mod.querySelectorAll('SubMod'));
            // Sort submods alphabetically by name for display
            submods.sort((a, b) => a.querySelector('Name').textContent.localeCompare(b.querySelector('Name').textContent));
            submods.forEach(submod => {
                submodSelect.append(new Option(submod.querySelector('Name').textContent));
            });
            fillForm(mod, false);
        }

        modSelect.on('change', updateSubmods);
        updateSubmods();

        submodSelect.on('change', () => {
            const mod = mods[modSelect.prop('selectedIndex')];
            const submods = Array.from(mod.querySelectorAll('SubMod'));
            // Sort submods alphabetically to match the display order
            submods.sort((a, b) => a.querySelector('Name').textContent.localeCompare(b.querySelector('Name').textContent));
            const submodIndex = submodSelect.prop('selectedIndex') - 1;
            const isSubmod = submodIndex >= 0;
            fillForm(isSubmod ? submods[submodIndex] : mod, isSubmod);
        });

        $('textarea').on('input', function () {
            autosizeTextarea(this);
        });

        // Save to XML element whenever form inputs change
        $('#modForm input, #modForm textarea').on('input change', function () {
            saveToXmlElement();
        });

        function startButtonCooldown() {
            let timeLeft = 10;
            const originalText = 'Save Changes';
            
            function updateButton() {
                if (timeLeft > 0) {
                    $('#saveBtn').prop('disabled', true).text(`Save Changes (${timeLeft})`);
                    timeLeft--;
                    setTimeout(updateButton, 1000);
                } else {
                    $('#saveBtn').prop('disabled', false).text(originalText);
                }
            }
            
            updateButton();
        }

        async function saveChanges() {
            if (!accessToken) {
                alert('Please authenticate with GitHub first.');
                return;
            }
            const form = document.getElementById('modForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }
            const name = $('#name').val();
            const version = $('#version').val();
            const description = $('#description').val();

            const isSubmod = submodSelect.prop('selectedIndex') > 0;
            if (!isSubmod && !version) {
                alert('Version is required for main mods.');
                return;
            }
            if (!name || !description) {
                alert('Name and Description are required.');
                return;
            }
            const isNewMod = modSelect.val() === null || modSelect.val() === '';
            const isNewSubmod = submodSelect.val() === 'new-submod';
            if (!isSubmod && !isNewSubmod) {
                const path = $('#path').val();
                const author = $('#author').val();
                if (!path || !author) {
                    alert('Installation Path and Author are required for main mods.');
                    return;
                }
            }
            try {
                // Hide PR link container at start of new save
                $('#prLinkContainer').hide();
                
                $('#saveBtn').prop('disabled', true).html('<span class="spinner-border spinner-border-sm me-2"></span>Saving...');
                showLoading('Creating pull request...');

                // Reconstruct XML using chunk-based preservation
                let reconstructedXml = '';
                
                for (let i = 0; i < xmlChunks.length; i++) {
                    const chunk = xmlChunks[i];
                    
                    if (chunk.type === 'text') {
                        // Preserve text chunks (whitespace, comments, etc.) exactly
                        reconstructedXml += chunk.content;
                    } else if (chunk.type === 'mod') {
                        const mod = chunk.element;
                        
                        // Check if this mod was modified by comparing the mod name instead of object reference
                        // This fixes the issue where sorting mods for UI creates reference mismatches
                        const modName = mod.querySelector('Name')?.textContent;
                        const isModModified = Array.from(modifiedMods).some(modifiedMod => 
                            modifiedMod.querySelector('Name')?.textContent === modName);
                        
                        if (isModModified) {
                            // Mod was modified - need to reconstruct it preserving submod formatting
                            // Find the actual modified mod element from the modified set
                            const actualModifiedMod = Array.from(modifiedMods).find(modifiedMod => 
                                modifiedMod.querySelector('Name')?.textContent === modName);
                            
                            if (actualModifiedMod) {
                                reconstructedXml += reconstructModWithSubmodPreservation(actualModifiedMod);
                            } else {
                                // Fallback - use original content
                                reconstructedXml += chunk.originalContent;
                            }
                        } else {
                            // Mod unchanged - use original text
                            reconstructedXml += chunk.originalContent;
                        }
                    }
                }
                
                // Handle new mods - add them at the end before closing tag
                if (isNewMod) {
                    const newModXml = createModElementAsXmlString(false);
                    // Insert before the closing </ModCatalog> tag
                    const closingTagPos = reconstructedXml.lastIndexOf('</ModCatalog>');
                    if (closingTagPos > -1) {
                        reconstructedXml = reconstructedXml.substring(0, closingTagPos) + 
                            '\n\n' + newModXml + '\n' +
                            reconstructedXml.substring(closingTagPos);
                    } else {
                        reconstructedXml += '\n\n' + newModXml;
                    }
                } else if (isNewSubmod) {
                    // Handle new submods by finding the target mod and inserting at the end
                    const selectedModIndex = modSelect.prop('selectedIndex');
                    const selectedMod = mods[selectedModIndex];
                    const selectedModName = selectedMod.querySelector('Name')?.textContent;
                    
                    // Find the chunk containing this mod by name instead of object reference
                    let targetChunkIndex = -1;
                    for (let i = 0; i < xmlChunks.length; i++) {
                        if (xmlChunks[i].type === 'mod') {
                            const chunkModName = xmlChunks[i].element.querySelector('Name')?.textContent;
                            if (chunkModName === selectedModName) {
                                targetChunkIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (targetChunkIndex >= 0) {
                        const modChunk = xmlChunks[targetChunkIndex];
                        
                        // Reconstruct this mod with the new submod
                        const newSubmodXml = createModElementAsXmlString(true);
                        let modXml = modChunk.originalContent;
                        
                        // Insert new submod before closing </Mod> tag
                        const closingModPos = modXml.lastIndexOf('</Mod>');
                        if (closingModPos > -1) {
                            modXml = modXml.substring(0, closingModPos) + 
                                '\n\t' + newSubmodXml.replace(/\n/g, '\n\t') + '\n' +
                                modXml.substring(closingModPos);
                        }
                        
                        // Update the chunk content
                        xmlChunks[targetChunkIndex].originalContent = modXml;
                        // Mark this mod as modified for proper handling
                        modifiedMods.add(selectedMod);
                        
                        // Rebuild the entire XML again
                        reconstructedXml = '';
                        for (let j = 0; j < xmlChunks.length; j++) {
                            const chunkItem = xmlChunks[j];
                            if (chunkItem.type === 'text') {
                                reconstructedXml += chunkItem.content;
                            } else if (chunkItem.type === 'mod') {
                                if (j === targetChunkIndex) {
                                    reconstructedXml += modXml;
                                } else {
                                    const chunkModName = chunkItem.element.querySelector('Name')?.textContent;
                                    const isChunkModModified = Array.from(modifiedMods).some(modifiedMod => 
                                        modifiedMod.querySelector('Name')?.textContent === chunkModName);
                                    
                                    if (isChunkModModified && j !== targetChunkIndex) {
                                        const actualModifiedMod = Array.from(modifiedMods).find(modifiedMod => 
                                            modifiedMod.querySelector('Name')?.textContent === chunkModName);
                                        if (actualModifiedMod) {
                                            reconstructedXml += reconstructModWithSubmodPreservation(actualModifiedMod);
                                        } else {
                                            reconstructedXml += chunkItem.originalContent;
                                        }
                                    } else {
                                        reconstructedXml += chunkItem.originalContent;
                                    }
                                }
                            }
                        }
                    }
                }
                
                const newXmlContent = reconstructedXml;
                
                // Debug: Log change information
                console.log('=== Save Changes Debug ===');
                console.log('Modified mods count:', modifiedMods.size);
                console.log('Modified submods count:', modifiedSubmods.size);
                console.log('Modified mod names:', Array.from(modifiedMods).map(mod => mod.querySelector('Name')?.textContent));
                console.log('Modified submod names:', Array.from(modifiedSubmods).map(submod => {
                    const parentMod = submod.closest('Mod');
                    return `${parentMod?.querySelector('Name')?.textContent} -> ${submod.querySelector('Name')?.textContent}`;
                }));
                console.log('Original XML length:', originalXmlText.length);
                console.log('New XML length:', newXmlContent.length);
                console.log('XML content changed:', newXmlContent !== originalXmlText);
                
                // Verify that we actually have changes to commit
                if (newXmlContent === originalXmlText && !isNewMod && !isNewSubmod) {
                    alert('No changes detected. Please make some modifications before saving.');
                    $('#saveBtn').prop('disabled', false).text('Save Changes');
                    hideLoading();
                    return;
                }
                
                const branchName = `mod-edit-${Date.now()}`;
                const commitMessage = isNewMod ? `Add new mod: ${name}` :
                    isNewSubmod ? `Add new submod: ${name}` :
                        `Update ${isSubmod ? 'submod' : 'mod'}: ${name}`;
                await createPullRequest(branchName, commitMessage, newXmlContent, currentXmlData.sha);
                
                // Start cooldown timer
                startButtonCooldown();
                
            } catch (error) {
                console.error('Save error:', error);
                alert('Error saving changes: ' + error.message);
                $('#saveBtn').prop('disabled', false).text('Save Changes');
            } finally {
                hideLoading();
            }
        }

        function createModElement(doc, isSubmod) {
            const element = doc.createElement(isSubmod ? 'SubMod' : 'Mod');
            addElementIfValue(doc, element, 'Name', $('#name').val());
            if (!isSubmod || $('#version').val()) {
                addElementIfValue(doc, element, 'Version', $('#version').val());
            }
            addElementIfValue(doc, element, 'InstallationPath', $('#path').val());
            if (!isSubmod) {
                addElementIfValue(doc, element, 'Author', $('#author').val());
            }
            addElementIfValue(doc, element, 'Description', $('#description').val());
            addElementIfValue(doc, element, 'Priority', $('#priority').val());
            addElementIfValue(doc, element, 'Category', $('#category').val());
            addElementIfValue(doc, element, 'ReleaseDate', $('#releaseDate').val());
            addElementIfValue(doc, element, 'Website', $('#website').val());
            addElementIfValue(doc, element, 'DownloadUrl', $('#downloadUrl').val());
            addElementIfValue(doc, element, 'PreviewFileUrl', $('#previewFileUrl').val());
            addElementIfValue(doc, element, 'PatchNotes', $('#patchNotes').val());
            addElementIfValue(doc, element, 'IncompatibleWith', $('#incompatibleWith').val());
            addElementIfValue(doc, element, 'MinimumMemoriaVersion', $('#minimumMemoriaVersion').val());
            return element;
        }

        function updateModElement(element, isSubmod) {
            updateElementText(element, 'Name', $('#name').val());
            if (!isSubmod || $('#version').val()) {
                updateElementText(element, 'Version', $('#version').val());
            }
            updateElementText(element, 'InstallationPath', $('#path').val());
            if (!isSubmod) {
                updateElementText(element, 'Author', $('#author').val());
            }
            updateElementText(element, 'Description', $('#description').val());
            updateElementText(element, 'Priority', $('#priority').val());
            updateElementText(element, 'Category', $('#category').val());
            updateElementText(element, 'ReleaseDate', $('#releaseDate').val());
            updateElementText(element, 'Website', $('#website').val());
            updateElementText(element, 'DownloadUrl', $('#downloadUrl').val());
            updateElementText(element, 'PreviewFileUrl', $('#previewFileUrl').val());
            updateElementText(element, 'PatchNotes', $('#patchNotes').val());
            updateElementText(element, 'IncompatibleWith', $('#incompatibleWith').val());
            updateElementText(element, 'MinimumMemoriaVersion', $('#minimumMemoriaVersion').val());
        }

        function addElementIfValue(doc, parent, tagName, value) {
            if (value) {
                const element = doc.createElement(tagName);
                element.textContent = value;
                parent.appendChild(element);
            }
        }

        function updateElementText(parent, tagName, value) {
            let element = parent.querySelector(tagName);
            if (value) {
                if (!element) {
                    element = parent.ownerDocument.createElement(tagName);
                    parent.appendChild(element);
                }
                element.textContent = value;
            } else if (element) {
                element.remove();
            }
        }

        function formatXmlForCatalog(xmlString) {
            return xmlString
                .replace(/<ModCatalog>/g, '<ModCatalog>\n')
                .replace(/<\/ModCatalog>/g, '\n</ModCatalog>')
                .replace(/<Mod>/g, '\n\n<Mod>')
                .replace(/<\/Mod>/g, '\n</Mod>')
                .replace(/<SubMod>/g, '\n\t<SubMod>')
                .replace(/<\/SubMod>/g, '\n\t</SubMod>')
                .replace(/<([^\/][^>]*)>([^<]+)<\/[^>]+>/g, '\n\t<$1>$2</$1>');
        }

        async function createPullRequest(branchName, commitMessage, content, baseSha) {
            const mainBranchResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/ref/heads/main`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            const mainBranchData = await mainBranchResponse.json();
            const mainSha = mainBranchData.object.sha;
            await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/refs`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: `refs/heads/${branchName}`,
                    sha: mainSha
                })
            });
            const updateResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${CATALOG_PATH}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: commitMessage,
                    content: btoa(new TextEncoder().encode(content).reduce((data, byte) => data + String.fromCharCode(byte), '')),
                    sha: baseSha,
                    branch: branchName
                })
            });
            if (!updateResponse.ok) {
                throw new Error('Failed to update file');
            }
            const prResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/pulls`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    title: commitMessage,
                    head: branchName,
                    base: 'main',
                    body: `This pull request was created automatically from the Memoria Mod Catalog Editor.\n\nChanges made:\n- ${commitMessage}`
                })
            });
            if (!prResponse.ok) {
                throw new Error('Failed to create pull request');
            }
            const prData = await prResponse.json();
            
            // Mark first successful save and show appropriate UI
            if (!hasSuccessfulSave) {
                hasSuccessfulSave = true;
                localStorage.setItem('memoria_has_successful_save', 'true');
                $('#createPrContainer').hide();
            }
            
            // Show the PR link
            $('#prLink').attr('href', prData.html_url).text(`Pull Request #${prData.number}`);
            $('#prLinkContainer').show();
            
            // Reset changed mods tracking after successful save
            resetChangedMods();
            
            alert(`Successfully created pull request #${prData.number}!`);
        }

        $('#saveBtn').click(e => {
            e.preventDefault();
            saveChanges();
        });

        $('#newModBtn').click(() => {
            if (confirm('Create a new mod? This will clear the current form and all unsaved changes.')) {
                isLoadingFormData = true;
                $('#modForm input, #modForm textarea').val('');
                $('#mainModFields').show();
                $('#modSelect').val(null).trigger('change.select2');
                $('#submodSelect').empty().append(new Option('Main')).val(null).trigger('change.select2');
                
                // Clear original form values for new mod
                originalFormValues = {};
                $('#modForm input, #modForm textarea').each(function() {
                    originalFormValues[this.id] = '';
                });
                
                isLoadingFormData = false;
                $('#name').focus();
            }
        });

        $('#newSubmodBtn').click(() => {
            const selectedModIndex = modSelect.prop('selectedIndex');
            if (selectedModIndex < 0) {
                alert('Please select a parent mod first.');
                return;
            }
            if (confirm('Create a new submod for the selected mod? This will clear the current form.')) {
                isLoadingFormData = true;
                $('#modForm input, #modForm textarea').val('');
                $('#mainModFields').hide();
                const newOption = new Option('(New SubMod)', 'new-submod');
                submodSelect.append(newOption);
                submodSelect.val('new-submod').trigger('change.select2');
                
                // Clear original form values for new submod
                originalFormValues = {};
                $('#modForm input, #modForm textarea').each(function() {
                    originalFormValues[this.id] = '';
                });
                
                isLoadingFormData = false;
                $('#name').focus();
            }
        });
        
        // Test preservation button handler
        $('#testPreservationBtn').click(() => {
            const results = testXmlPreservation();
            
            // Test the serialization fix by verifying DOM modifications produce XML changes
            console.log('=== Testing serialization fix ===');
            const serializationResults = testSerializationFix();
            
            // Also test modification simulation
            console.log('=== Testing modification simulation ===');
            testModificationPreservation();
            
            let message = 'XML Preservation Test Results:\n\n';
            message += `✅ Perfect reconstruction: ${results.perfectReconstruction ? 'PASS' : 'FAIL'}\n`;
            message += `✅ Original order preserved: ${results.orderPreserved ? 'PASS' : 'FAIL'}\n`;
            message += `✅ UI displays alphabetically: ${results.uiAlphabetical ? 'PASS' : 'FAIL'}\n`;
            message += `✅ Serialization fix works: ${serializationResults.serializationWorks ? 'PASS' : 'FAIL'}\n`;
            
            if (results.perfectReconstruction && results.orderPreserved && results.uiAlphabetical && serializationResults.serializationWorks) {
                message += '\n🎉 All tests PASSED! XML preservation system is working correctly.';
                message += '\n\nCheck console for detailed test results and diff output.';
            } else {
                message += '\n⚠️ Some tests FAILED. Check console for details.';
            }
            
            alert(message);
        });
        
        // Test function to verify the serialization fix works correctly
        function testSerializationFix() {
            console.log('Testing serialization fix: DOM modifications should produce XML changes...');
            
            if (mods.length === 0) {
                console.log('No mods available for testing');
                return { serializationWorks: false };
            }
            
            // Save original state
            const originalModifiedMods = new Set(modifiedMods);
            const originalModifiedSubmods = new Set(modifiedSubmods);
            
            try {
                // Test 1: Modify a field and verify XML changes
                const testMod = mods[0];
                const modName = testMod.querySelector('Name')?.textContent || '';
                console.log(`Testing with mod: ${modName}`);
                
                // Get original XML for this mod
                const originalModXml = originalModXml.get(testMod);
                if (!originalModXml) {
                    console.log('Could not find original XML for test mod');
                    return { serializationWorks: false };
                }
                
                // Extract original description value from XML
                const originalDescription = getValueFromXmlText(originalModXml, 'Description');
                console.log(`Original description: "${originalDescription}"`);
                
                // Modify the DOM element with a new description
                const testDescription = 'TEST SERIALIZATION FIX - ' + Date.now();
                let descElement = testMod.querySelector('Description');
                if (!descElement) {
                    descElement = testMod.ownerDocument.createElement('Description');
                    testMod.appendChild(descElement);
                }
                descElement.textContent = testDescription;
                
                console.log(`Modified description to: "${testDescription}"`);
                
                // Mark as modified
                modifiedMods.add(testMod);
                
                // Test the updateModFieldsInXmlText function
                const updatedModXml = updateModFieldsInXmlText(originalModXml, testMod);
                
                // Verify the XML actually changed
                const xmlChanged = updatedModXml !== originalModXml;
                console.log(`XML changed after modification: ${xmlChanged}`);
                
                // Verify the new description is in the updated XML
                const containsNewDescription = updatedModXml.includes(testDescription);
                console.log(`Updated XML contains new description: ${containsNewDescription}`);
                
                // Show a diff-like comparison
                if (xmlChanged) {
                    console.log('=== XML DIFF ===');
                    console.log('BEFORE:');
                    const beforeLines = originalModXml.split('\n');
                    beforeLines.forEach((line, i) => {
                        if (line.includes('<Description>')) {
                            console.log(`${i + 1}: ${line}`);
                        }
                    });
                    
                    console.log('AFTER:');
                    const afterLines = updatedModXml.split('\n');
                    afterLines.forEach((line, i) => {
                        if (line.includes('<Description>')) {
                            console.log(`${i + 1}: ${line}`);
                        }
                    });
                    console.log('=== END DIFF ===');
                }
                
                // Test 2: Test with submod if available
                let submodTestPassed = true;
                const submods = testMod.querySelectorAll('SubMod');
                if (submods.length > 0) {
                    const testSubmod = submods[0];
                    const submodName = testSubmod.querySelector('Name')?.textContent || '';
                    console.log(`Testing submod: ${submodName}`);
                    
                    // Get original submod XML
                    const originalSubmodXmlText = originalSubmodXml.get(testSubmod);
                    if (originalSubmodXmlText) {
                        // Modify submod description
                        const testSubmodDescription = 'TEST SUBMOD SERIALIZATION - ' + Date.now();
                        let submodDescElement = testSubmod.querySelector('Description');
                        if (!submodDescElement) {
                            submodDescElement = testSubmod.ownerDocument.createElement('Description');
                            testSubmod.appendChild(submodDescElement);
                        }
                        submodDescElement.textContent = testSubmodDescription;
                        
                        // Mark as modified
                        modifiedSubmods.add(testSubmod);
                        
                        // Test the updateSubmodFieldsInXmlText function
                        const updatedSubmodXml = updateSubmodFieldsInXmlText(originalSubmodXmlText, testSubmod);
                        
                        const submodXmlChanged = updatedSubmodXml !== originalSubmodXmlText;
                        const containsNewSubmodDescription = updatedSubmodXml.includes(testSubmodDescription);
                        
                        console.log(`Submod XML changed: ${submodXmlChanged}`);
                        console.log(`Submod XML contains new description: ${containsNewSubmodDescription}`);
                        
                        submodTestPassed = submodXmlChanged && containsNewSubmodDescription;
                    }
                }
                
                // Restore original description
                descElement.textContent = originalDescription;
                
                const testPassed = xmlChanged && containsNewDescription && submodTestPassed;
                console.log(`Serialization fix test result: ${testPassed ? 'PASS' : 'FAIL'}`);
                
                return { serializationWorks: testPassed };
                
            } catch (error) {
                console.error('Error during serialization test:', error);
                return { serializationWorks: false };
            } finally {
                // Restore original modification state
                modifiedMods.clear();
                modifiedSubmods.clear();
                originalModifiedMods.forEach(mod => modifiedMods.add(mod));
                originalModifiedSubmods.forEach(submod => modifiedSubmods.add(submod));
            }
        }
        
        // Test function to simulate making modifications and verify preservation
        function testModificationPreservation() {
            console.log('Testing modification preservation...');
            
            if (mods.length === 0) {
                console.log('No mods available for testing');
                return;
            }
            
            // Save original state
            const originalModifiedMods = new Set(modifiedMods);
            const originalModifiedSubmods = new Set(modifiedSubmods);
            
            try {
                // Test 1: Modify first mod description
                const testMod = mods[0];
                const originalDescription = testMod.querySelector('Description')?.textContent || '';
                const testDescription = 'TEST MODIFIED DESCRIPTION - ' + Date.now();
                
                // Update the DOM element
                let descElement = testMod.querySelector('Description');
                if (!descElement) {
                    descElement = testMod.ownerDocument.createElement('Description');
                    testMod.appendChild(descElement);
                }
                descElement.textContent = testDescription;
                
                // Mark as modified
                modifiedMods.add(testMod);
                
                // Test reconstruction
                const reconstructedModXml = reconstructModWithSubmodPreservation(testMod);
                console.log('Test mod reconstruction includes new description:', 
                    reconstructedModXml.includes(testDescription));
                
                // Test 2: Test full XML reconstruction
                let reconstructedXml = '';
                for (let i = 0; i < xmlChunks.length; i++) {
                    const chunk = xmlChunks[i];
                    if (chunk.type === 'text') {
                        reconstructedXml += chunk.content;
                    } else if (chunk.type === 'mod') {
                        const mod = chunk.element;
                        const modName = mod.querySelector('Name')?.textContent;
                        const isModModified = Array.from(modifiedMods).some(modifiedMod => 
                            modifiedMod.querySelector('Name')?.textContent === modName);
                        
                        if (isModModified) {
                            const actualModifiedMod = Array.from(modifiedMods).find(modifiedMod => 
                                modifiedMod.querySelector('Name')?.textContent === modName);
                            if (actualModifiedMod) {
                                reconstructedXml += reconstructModWithSubmodPreservation(actualModifiedMod);
                            } else {
                                reconstructedXml += chunk.originalContent;
                            }
                        } else {
                            reconstructedXml += chunk.originalContent;
                        }
                    }
                }
                
                console.log('Full reconstruction includes test description:', 
                    reconstructedXml.includes(testDescription));
                console.log('Full reconstruction differs from original:', 
                    reconstructedXml !== originalXmlText);
                
                // Restore original description
                descElement.textContent = originalDescription;
                
            } finally {
                // Restore original modification state
                modifiedMods.clear();
                modifiedSubmods.clear();
                originalModifiedMods.forEach(mod => modifiedMods.add(mod));
                originalModifiedSubmods.forEach(submod => modifiedSubmods.add(submod));
            }
        }
    })();
</script>
</body>
</html>